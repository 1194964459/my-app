# 函数组件、类组件 区别

## 两者 state 比较
| 特性	| 类组件（Class Component）| 	函数组件（Function Component）|
| ---- | ---- | ---- | 
| 定义方式	| 在 constructor 中通过 this.state = { ... } 定义	| 通过 useState(initialValue) 定义，每次声明一个独立状态|
| 状态结构	| 所有状态集中在一个对象中	| 多个独立状态变量，各自管理|
| 更新方法	| this.setState(newState) 或 this.setState(prev => newState)	| 每个状态对应独立的更新函数（如 setCount）|
| 对象更新行为	| 自动合并对象字段	| 需手动合并（用扩展运算符等）|
| **依赖旧状态更新**<br/>(参数是函数，而非对象)| 	```this.setState(prevState => { ... })```	| ```setX(prev => { ... })```|
| **异步更新后获取值**	| ```this.setState(..., callback)``` 新增个回调参数	| ```useEffect(() => { ... }, [state])```|

## 其他比较
| 特性	| 类组件（Class Component）| 	函数组件（Function Component）|
| ---- | ---- | ---- | 
| 语法基础 | 基于 ES6 类，继承 React.Component	|基于普通函数，接收 props 并返回 JSX |
| this 关键字 |	存在，需手动绑定事件处理函数 | 	不存在，无需处理 this 绑定 |
| 副作用处理 |	使用生命周期方法（componentDidMount 等） |	使用 useEffect Hook |
| 性能优化	 | 通过 shouldComponentUpdate 或 React.PureComponent  |	通过 React.memo、useMemo、useCallback |

## 类组件/函数组件 浅比较陷阱 及解决方案
参考：  
[React中的不可变数据原则](./0.0__不可变数据原则.md)

[类组件与函数组件 浅比较陷阱及解决方案](./0.0__浅比较陷阱_重要.md)

[函数组件“误更新”解决方案](./1.0.1__函数式组件_误更新解决.md)

## React.memo
用于函数组件，浅比较，是一个高阶组件（HOC）。它通过缓存组件的渲染结果，仅在**组件接收的 props 发生变化时才重新渲染**，否则直接复用上次的渲染结果。
> 状态相关的三种：props、组件内部状态（useState）或上下文（useContext）   
> React.memo，配合 useMemo（缓存对象/数组）和 useCallback（缓存函数）处理引用类型 props，

```js
// 定义函数组件
const MyComponent = (props) => {
  return <div>{props.name}</div>;
};

// 使用 memo 包装（默认浅比较 props）
const MemoizedComponent = React.memo(MyComponent);

// 自定义比较逻辑（可选）
const MemoizedComponent = React.memo(MyComponent, (prevProps, nextProps) => {
  // 返回 true：props 未变化，不重渲染
  // 返回 false：props 变化，需要重渲染
  return prevProps.name === nextProps.name;
});
```

## 最佳实践
* 函数组件：优先使用 React.memo，配合 useMemo（缓存对象/数组）和 useCallback（缓存函数）处理引用类型 props，避免浅比较失效。
* 类组件：
  * 简单场景用 React.PureComponent（自动浅比较 props 和 state）。
  * 复杂场景重写 shouldComponentUpdate，精确控制重渲染时机。
* 避免过度优化：两者都有性能成本（比较 props/state 需要时间），对于渲染成本低的组件，优化可能得不偿失。

## useState与setState比较


