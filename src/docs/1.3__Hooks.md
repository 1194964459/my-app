# Hooks

Hooks 是从 React 16.8 版本开始引入的特性，它允许开发者在函数组件中使用状态（state）和其他 React 特性.

参考：[Hooks](https://www.doubao.com/thread/wad98fe42b51020bf)

### 1. useState：管理组件状态
```js
const [state, setState] = useState(initialValue);
```
注意：setState 是异步的，若新状态依赖于旧状态，应使用函数形式：
```js
setCount(prevCount => prevCount + 1); // 确保基于最新状态更新
```

### 2. useEffect - 处理副作用（异步）
参开：[useEffect 详解](./1.3.1__useEffect.md)

作用：在函数组件中处理副作用（如数据请求、DOM 操作、订阅事件等），替代类组件中的```componentDidMount、componentDidUpdate 和 componentWillUnmount```。
> **useLayoutEffect**：与useEffect类似，不过是 同步的，可能阻塞浏览器渲染，优先使用 useEffect。
```js
useEffect(() => {
  // 副作用逻辑（如请求数据、添加事件监听）
  
  return () => {
    // 清理函数（如移除事件监听、取消订阅）
  };
}, [dependencies]); // 依赖数组：当数组中的值变化时，才会重新执行副作用
```
常见场景：
* 空依赖数组 []：仅在组件挂载时执行一次（类似 componentDidMount）。
* 依赖数组有值：当**依赖项变化时**执行（类似 componentDidMount + componentDidUpdate）。
* 清理函数：在**组件卸载**或**依赖项变化前**执行（类似 componentWillUnmount）。

### 3. useContext - 跨组件共享数据
* 避免通过 props 层层传递。
* 需配合 createContext 创建的 Context 对象使用。
```js
// 1. 创建Context
const ThemeContext = React.createContext('light');  // light是默认值
```
```js
// 2. 上层组件提供数据

// 法1：使用默认值：
function App() {
  return (
    <ThemedButton />
  );
}

// 法2：使用 value
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <ThemedButton />
    </ThemeContext.Provider>
  );
}
```

```js
// 3. 子组件通过useContext获取数据
function ThemedButton() {
  const theme = useContext(ThemeContext);
  return <button style={{ background: theme === 'dark' ? 'black' : 'white' }}>Click me</button>;
}
```

### 4. useReducer - 复杂状态管理
通过 reducer 函数管理复杂状态（类似 Redux 的思想）  
```jsx
const [state, dispatch] = useReducer(reducer, initialState);
```
* reducer：接收 (state, action) 并返回新状态的函数。
* dispatch：用于触发 action 的函数（通过 action 类型更新状态）。
```js
// 定义reducer
function todoReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, { id: Date.now(), text: action.text, done: false }];
    case 'TOGGLE_TODO':
      return state.map(todo => 
        todo.id === action.id ? { ...todo, done: !todo.done } : todo
      );
    default:
      return state;
  }
}

// 使用useReducer
function TodoList() {
  const [todos, dispatch] = useReducer(todoReducer, []);
  const [text, setText] = useState('');
  
  const handleAdd = () => {
    dispatch({ type: 'ADD_TODO', text });
    setText('');
  };
  
  return (
    <div>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={handleAdd}>Add</button>
      <ul>
        {todos.map(todo => (
          <li 
            key={todo.id} 
            style={{ textDecoration: todo.done ? 'line-through' : 'none' }}
            onClick={() => dispatch({ type: 'TOGGLE_TODO', id: todo.id })}
          >
            {todo.text}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### 5.useMemo：缓存计算结果
useMemo 缓存计算结果（通常是对象、数组等引用类型），避免组件重新渲染时“重复计算”

经常 与 React.memo 配合，只有当子组件用 React.memo 包装时，useMemo 缓存引用的作用才会体现（否则无需缓存）。

```js
const memoizedValue = useMemo(() => {
  // 计算逻辑（如复杂的数组处理、数学计算）
  return result;
}, [dependencies]); // 依赖变化时，才会重新计算
```
若依赖为空，永远返回同一个引用，如下：
```js
const user = useMemo(() => ({ name: "Alice" }), []); 
```

### 6. useCallback：缓存函数引用
避免因组件重新渲染导致**函数被频繁创建**，优化子组件性能（尤其配合 React.memo 时）。

* 适用场景：缓存需要传递给子组件的回调函数（尤其是子组件用 React.memo 包装时）。
* 与 useMemo 的关系： ```useCallback(fn, deps)``` 等价于 ```useMemo(() => fn, deps)```，前者是专门用于函数的语法糖。

```js
const memoizedCallback = useCallback(() => {
  // 函数逻辑
}, [dependencies]); // 依赖数组：依赖变化时，函数才会重新创建
```

示例：
```js
function Parent() {
  const [count, setCount] = useState(0);
  
  // 缓存handleClick函数，仅当count变化时重新创建
  const handleClick = useCallback(() => {
    console.log(`Count: ${count}`);
  }, [count]);
  
  return <Child onClick={handleClick} />;
}

// 子组件使用React.memo避免不必要的重渲染
const Child = React.memo(({ onClick }) => {
  return <button onClick={onClick}>Click</button>;
});
```



////   
用 useMemo 缓存对象/数组：const user = useMemo(() => ({ name: "Alice" }), []);
用 useCallback 缓存函数：const handleClick = useCallback(() => {}, []);
React.momo（高阶组件）: 通过缓存组件渲染结果，避免 props 未变化时的冗余渲染。

